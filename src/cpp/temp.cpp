#include <iostream> using namespace std; const int MN = 10; int par[MN]; // 해당 원소의 부모.(혹은 대표자) int rnk[MN]; // rank, 트리의 깊이의 상한, 최악의 경우를 방지하기 위해 사용 void init(int N) { // 트리를 N개 만들었다. for(int i=0; i<N; ++i){ par[i]=i, rnk[i]=1; } } int find(int x) { // 해당 트리의 루트를 찾는다. if(par[x]==x) return x; else return par[x] = find(par[x]); } void unite(int x, int y){ // union이 예약어여서 대체 x=find(x); y=find(y); // 대표자 찾기 if(x==y) return; if(rnk[x]>rnk[y]) { // 트리의 깊이가 얕은 쪽이 깊은쪽 밑에 합쳐지도록. swap(x, y); } par[x] = y; // x의 부모를 y로 변경. if(rnk[x] == rnk[y]){ rnk[y]++; // x의 부모가 y로 변경되었으니 y의 rnk만 ++. } } int main(){ init(MN); while(true) { cout << "합칠 원소 입력 : " << '\n'; int A, B; cin >> A >> B; unite(A-1, B-1); for(int i=0; i<MN; ++i){ printf("%4d", i+1); } cout << '\n'; for(int i=0; i<MN; ++i){ printf("%4d", find(i)+1); } cout << '\n'; } }

