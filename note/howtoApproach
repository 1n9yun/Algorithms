* DFS, BFS
*	완탐?
*	넓은 범위 DFS, BFS - 스택 오버 플로우|메모리 초과 -	ex) boj2206, boj1987
	>> 되도록이면 최단 거리는 BFS, 경로 탐색은 DFS ( 인거 같은데 크기가 커지면 DFS는 터져버려. 그럼 BFS로 하되, 모두 탐색하도록 check 조절 ( int[][] check )) 
*	DFS, BFS 중에 check 할 때 문제에 추가적인 조건들(말이 되고픈 원숭이에서 말 점프나 벽 부수고 이동하기 등의 스킬)이 있으면
	그 조건 마다 체크를 해야되는지 확인해야함 ( 모든 경우를 탐색 하는지를 생각해봐야 함 )
*	BFS에서 그냥 모든 경우 가게 해놓고 poll 이후에 체크하는 문제도 있었음 이 아니라 메모이제이션. - boj17071
*	돌다가 더 안돌아도 될 경우 (최단 거리를 구하는 문제인데 현재 최단 거리보다 길어지면 더 안돌아도 됨)

*	최소를 찾는 문제에서 BFS를 사용할 경우, 꺼내어 보는 step이 단조증가를 이루어 종료 조건에 처음 도달했을 때 최소를 찾을 수 있어야 함. 
		ex)	큐안의 시간이 1, 1, 1, 2, 2, 2 , 3, 3, 3 식으로 저장
			boj1726에서 회전과 이동을 동시에 처리하면 한 step에서 나아가는 다음 스텝이 여러 스텝으로 나뉨. <- 그래서 실패 	라기보단 모든 경우를 탐색하지 못하기 때문에 실패 ( 모든 경우를 탐색한다면 여러 스텝으로 나뉘어도 답은 나온다는 얘기. 다만 답을 계속 갱신해야겠지 )
*	bfs, dfs로는 중간에 가지가 쳐지는 경로를 만들 수 없음(한 붓 긋기 경로밖에 못 만듬) - boj1941 (먼저 조합으로 경우의 수를 구한 후 풀이?)
*	최단 거리가 아닌 다른 조건을 최소로 찾아야 되는 경우 보통 PriorityQueue로 해결 됨 ex) swea 종건이 이름짓기
>>>	최단 거리 인지 경로 탐색 해야되는지 - 추가 조건들도 check에 추가해야 하는지(추가 조건에 의해 한 상태에서 최소 값이 달라지는 경우) - 불필요한 반복 break


* 순열, 조합
*	완전 탐색
*	더 이상 안돌아도 되는 경우 확인할 때 (ex 최소값을 구하는 문제에서 이미 최소값이 나왔을 때 다 return)


* DP
*	경우의 수, 최대 최소 문제라면 dp 인가?
	>> 최적 부분 구조를 갖는지 확인
	>> 갖는다면 dp. 그러면 부분 문제 정의(상태 표현)
	>> 정의된 상태를 바탕으로 백 트래킹(선형 dp일 경우 점화식 정의)
*	dp 배열은 부분 문제의 모든 상태를 포함하고 있어야 함, 백 트래킹의 매개 변수 또한.


* 시뮬레이션
*	스택 or 큐 등등 사용할 때 push, pop을 많이 하면 시간, 메모리 많이 올라감. 배열로 직접 구현해서 사용하면 빠름
		>>	그니까 그냥 스택이나 큐 써야되면 구현해서 쓰든가..
		>>	Deque도 빠르긴 함. 근데 배열 리사이징에서 시간이 걸리나봄?? boj3954에서 15%정도 느리고 메모리 많이씀
		

* 다익스트라와 MST 차이 
	다익스트라는 각 경로의 최소 비용을 저장하는 거임
	전체를 연결했을 때 최소 비용을 구하는 MST랑은 다름!!!

* 기타
*	처음에 입력 범위, 입력 많은지 확인부터해
*	check 배열 같은 경우 재활용 해야 할 때 재할당 대신 fill 함수로 초기화 하는게 메모리를 아낄 수 있음?
	>>	시간은 모르겠음 boj1941 에서 시간이 좀 줄긴 했는데 
*	시간과 메모리는 반비례관계임을 항상 생각해라임마 시간 오래걸릴거같으면 저장해야되나? 생각해보란말이지
*	입력 많은지 확인, 많으면 BufferedReader


* 배열 회전
*	r = 세로 길이
*	c = 가로 길이	(원배열)
*
*	nr = 세로 길이
*	nc = 가로 길이	(회전된 배열)
*	i : 0 ~ nr, j : 0 ~ nc
*	(i, j) -> (r-j-1, i)